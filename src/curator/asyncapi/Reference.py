# Auto-generated by @asyncapi/modelina
# DO NOT EDIT MANUALLY

from __future__ import annotations

from typing import Any, List, Optional, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    field_validator,
    model_serializer,
    model_validator,
)

from .EntityIdValueSnak import EntityIdValueSnak
from .ExternalIdValueSnak import ExternalIdValueSnak
from .GlobeCoordinateValueSnak import GlobeCoordinateValueSnak
from .NoValueSnak import NoValueSnak
from .QuantityValueSnak import QuantityValueSnak
from .SomeValueSnak import SomeValueSnak
from .StringValueSnak import StringValueSnak
from .TimeValueSnak import TimeValueSnak
from .UrlValueSnak import UrlValueSnak


class Reference(BaseModel):
    snaks: dict[
        str,
        List[
            Union[
                NoValueSnak,
                SomeValueSnak,
                Union[
                    EntityIdValueSnak,
                    ExternalIdValueSnak,
                    GlobeCoordinateValueSnak,
                    QuantityValueSnak,
                    StringValueSnak,
                    TimeValueSnak,
                    UrlValueSnak,
                ],
            ]
        ],
    ] = Field(description="""Claims""")
    snaks_order: List[str] = Field(default=[], alias="""snaks-order""")
    hash: Optional[str] = Field(default=None)
    additional_properties: dict[str, Any] = Field(default={}, exclude=True)

    model_config = ConfigDict(populate_by_name=True)

    @field_validator("additional_properties", mode="before")
    @classmethod
    def parse_empty_dict(cls, v):
        if v is None:
            return {}
        return v

    @field_validator("snaks_order", mode="before")
    @classmethod
    def parse_empty_list(cls, v):
        if v is None:
            return []
        return v

    @model_serializer(mode="wrap")
    def custom_serializer(self, handler):
        serialized_self = handler(self)
        additional_properties = getattr(self, "additional_properties")
        if additional_properties is not None:
            for key, value in additional_properties.items():
                # Never overwrite existing values, to avoid clashes
                if key not in serialized_self:
                    serialized_self[key] = value

        return serialized_self

    @model_validator(mode="before")
    @classmethod
    def unwrap_additional_properties(cls, data):
        if not isinstance(data, dict):
            try:
                data = data.model_dump()

            except AttributeError:
                return data

        data = data.copy()
        json_properties = list(data.keys())
        known_object_properties = [
            "snaks",
            "snaks_order",
            "hash",
            "additional_properties",
        ]
        unknown_object_properties = [
            element
            for element in json_properties
            if element not in known_object_properties
        ]
        # Ignore attempts that validate regular models, only when unknown input is used we add unwrap extensions
        if len(unknown_object_properties) == 0:
            return data

        known_json_properties = ["snaks", "snaks-order", "hash", "additionalProperties"]
        additional_properties = data.get("additional_properties", {})
        for obj_key in unknown_object_properties:
            if not known_json_properties.__contains__(obj_key):
                additional_properties[obj_key] = data.pop(obj_key, None)
        data["additional_properties"] = additional_properties
        return data
